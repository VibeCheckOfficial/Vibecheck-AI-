{
  "Secure API Endpoint": {
    "prefix": ["vc-api", "secure-api"],
    "body": [
      "// VibeCheck: Secure API endpoint pattern",
      "import { z } from 'zod';",
      "import { rateLimit } from '@/lib/rate-limit';",
      "",
      "const ${1:schema} = z.object({",
      "  ${2:field}: z.${3:string}(),",
      "});",
      "",
      "export async function ${4:POST}(request: Request) {",
      "  try {",
      "    // Rate limiting",
      "    const ip = request.headers.get('x-forwarded-for') ?? 'unknown';",
      "    const { success } = await rateLimit.limit(ip);",
      "    if (!success) {",
      "      return Response.json({ error: 'Too many requests' }, { status: 429 });",
      "    }",
      "",
      "    // Input validation",
      "    const body = await request.json();",
      "    const result = ${1:schema}.safeParse(body);",
      "    if (!result.success) {",
      "      return Response.json({ error: result.error.flatten() }, { status: 400 });",
      "    }",
      "",
      "    // Business logic",
      "    ${0}",
      "",
      "    return Response.json({ success: true });",
      "  } catch (error) {",
      "    console.error('API Error:', error);",
      "    return Response.json({ error: 'Internal server error' }, { status: 500 });",
      "  }",
      "}"
    ],
    "description": "Create a secure API endpoint with validation and rate limiting"
  },
  
  "Secure Database Query": {
    "prefix": ["vc-db", "secure-query"],
    "body": [
      "// VibeCheck: Parameterized query (SQL injection safe)",
      "const result = await db",
      "  .select()",
      "  .from(${1:table})",
      "  .where(eq(${1:table}.${2:column}, ${3:value}))",
      "  .limit(${4:100});",
      "",
      "${0}"
    ],
    "description": "Create a safe parameterized database query"
  },
  
  "Secure Authentication Check": {
    "prefix": ["vc-auth", "secure-auth"],
    "body": [
      "// VibeCheck: Secure authentication pattern",
      "import { getServerSession } from 'next-auth';",
      "import { authOptions } from '@/lib/auth';",
      "",
      "export async function ${1:GET}(request: Request) {",
      "  const session = await getServerSession(authOptions);",
      "  ",
      "  if (!session?.user) {",
      "    return Response.json({ error: 'Unauthorized' }, { status: 401 });",
      "  }",
      "",
      "  // Authorization check",
      "  if (!hasPermission(session.user, '${2:permission}')) {",
      "    return Response.json({ error: 'Forbidden' }, { status: 403 });",
      "  }",
      "",
      "  ${0}",
      "}"
    ],
    "description": "Add secure authentication and authorization checks"
  },
  
  "Secure File Upload": {
    "prefix": ["vc-upload", "secure-upload"],
    "body": [
      "// VibeCheck: Secure file upload pattern",
      "const ALLOWED_TYPES = ['image/jpeg', 'image/png', 'image/webp'];",
      "const MAX_SIZE = 5 * 1024 * 1024; // 5MB",
      "",
      "async function handleUpload(file: File) {",
      "  // Validate file type",
      "  if (!ALLOWED_TYPES.includes(file.type)) {",
      "    throw new Error('Invalid file type');",
      "  }",
      "",
      "  // Validate file size",
      "  if (file.size > MAX_SIZE) {",
      "    throw new Error('File too large');",
      "  }",
      "",
      "  // Generate safe filename",
      "  const ext = file.name.split('.').pop()?.toLowerCase();",
      "  const safeName = `\\${crypto.randomUUID()}.\\${ext}`;",
      "",
      "  // Upload to secure storage",
      "  ${0}",
      "",
      "  return { filename: safeName };",
      "}"
    ],
    "description": "Secure file upload with validation"
  },
  
  "Secure Environment Variable": {
    "prefix": ["vc-env", "secure-env"],
    "body": [
      "// VibeCheck: Secure environment variable access",
      "function getRequiredEnv(key: string): string {",
      "  const value = process.env[key];",
      "  if (!value) {",
      "    throw new Error(`Missing required environment variable: \\${key}`);",
      "  }",
      "  return value;",
      "}",
      "",
      "const ${1:CONFIG} = {",
      "  ${2:apiKey}: getRequiredEnv('${3:API_KEY}'),",
      "  ${0}",
      "} as const;"
    ],
    "description": "Safely access required environment variables"
  },
  
  "Secure Password Hashing": {
    "prefix": ["vc-hash", "secure-password"],
    "body": [
      "// VibeCheck: Secure password hashing with bcrypt",
      "import bcrypt from 'bcryptjs';",
      "",
      "const SALT_ROUNDS = 12;",
      "",
      "export async function hashPassword(password: string): Promise<string> {",
      "  return bcrypt.hash(password, SALT_ROUNDS);",
      "}",
      "",
      "export async function verifyPassword(",
      "  password: string,",
      "  hash: string",
      "): Promise<boolean> {",
      "  return bcrypt.compare(password, hash);",
      "}",
      "",
      "${0}"
    ],
    "description": "Secure password hashing functions"
  },
  
  "Secure CORS Configuration": {
    "prefix": ["vc-cors", "secure-cors"],
    "body": [
      "// VibeCheck: Secure CORS configuration",
      "const ALLOWED_ORIGINS = [",
      "  'https://${1:yourdomain.com}',",
      "  process.env.NODE_ENV === 'development' && 'http://localhost:3000',",
      "].filter(Boolean) as string[];",
      "",
      "export function corsHeaders(request: Request): Headers {",
      "  const origin = request.headers.get('origin');",
      "  const headers = new Headers();",
      "",
      "  if (origin && ALLOWED_ORIGINS.includes(origin)) {",
      "    headers.set('Access-Control-Allow-Origin', origin);",
      "    headers.set('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');",
      "    headers.set('Access-Control-Allow-Headers', 'Content-Type, Authorization');",
      "    headers.set('Access-Control-Max-Age', '86400');",
      "  }",
      "",
      "  return headers;",
      "}",
      "",
      "${0}"
    ],
    "description": "Secure CORS configuration with allowed origins"
  },
  
  "Secure Input Sanitization": {
    "prefix": ["vc-sanitize", "secure-input"],
    "body": [
      "// VibeCheck: Input sanitization utilities",
      "import DOMPurify from 'isomorphic-dompurify';",
      "",
      "export function sanitizeHtml(input: string): string {",
      "  return DOMPurify.sanitize(input, {",
      "    ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'p', 'br'],",
      "    ALLOWED_ATTR: [],",
      "  });",
      "}",
      "",
      "export function sanitizeFilename(input: string): string {",
      "  return input",
      "    .replace(/[^a-zA-Z0-9.-]/g, '_')",
      "    .replace(/\\.\\./g, '_')",
      "    .slice(0, 255);",
      "}",
      "",
      "export function sanitizeUrl(input: string): string | null {",
      "  try {",
      "    const url = new URL(input);",
      "    if (!['http:', 'https:'].includes(url.protocol)) {",
      "      return null;",
      "    }",
      "    return url.toString();",
      "  } catch {",
      "    return null;",
      "  }",
      "}",
      "",
      "${0}"
    ],
    "description": "Input sanitization utilities for XSS prevention"
  },
  
  "Secure JWT Verification": {
    "prefix": ["vc-jwt", "secure-jwt"],
    "body": [
      "// VibeCheck: Secure JWT verification",
      "import { jwtVerify, SignJWT } from 'jose';",
      "",
      "const SECRET = new TextEncoder().encode(process.env.JWT_SECRET!);",
      "const ALG = 'HS256';",
      "",
      "export async function signToken(payload: Record<string, unknown>): Promise<string> {",
      "  return new SignJWT(payload)",
      "    .setProtectedHeader({ alg: ALG })",
      "    .setIssuedAt()",
      "    .setExpirationTime('${1:1h}')",
      "    .sign(SECRET);",
      "}",
      "",
      "export async function verifyToken(token: string) {",
      "  try {",
      "    const { payload } = await jwtVerify(token, SECRET, {",
      "      algorithms: [ALG],",
      "    });",
      "    return { valid: true, payload };",
      "  } catch {",
      "    return { valid: false, payload: null };",
      "  }",
      "}",
      "",
      "${0}"
    ],
    "description": "Secure JWT signing and verification"
  },
  
  "Secure Redirect": {
    "prefix": ["vc-redirect", "secure-redirect"],
    "body": [
      "// VibeCheck: Safe redirect (prevents open redirect)",
      "const ALLOWED_HOSTS = ['${1:yourdomain.com}'];",
      "",
      "function safeRedirect(url: string, fallback = '/'): string {",
      "  try {",
      "    const parsed = new URL(url, 'https://placeholder.com');",
      "    ",
      "    // Only allow relative paths or allowed hosts",
      "    if (parsed.host === 'placeholder.com') {",
      "      return parsed.pathname + parsed.search;",
      "    }",
      "    ",
      "    if (ALLOWED_HOSTS.includes(parsed.host)) {",
      "      return url;",
      "    }",
      "    ",
      "    return fallback;",
      "  } catch {",
      "    return fallback;",
      "  }",
      "}",
      "",
      "${0}"
    ],
    "description": "Prevent open redirect vulnerabilities"
  },
  
  "Secure Error Handling": {
    "prefix": ["vc-error", "secure-error"],
    "body": [
      "// VibeCheck: Secure error handling (no info leakage)",
      "export class AppError extends Error {",
      "  constructor(",
      "    public statusCode: number,",
      "    public userMessage: string,",
      "    public internalMessage?: string",
      "  ) {",
      "    super(internalMessage || userMessage);",
      "  }",
      "}",
      "",
      "export function handleError(error: unknown) {",
      "  // Log full error internally",
      "  console.error('Internal error:', error);",
      "",
      "  // Return safe error to user",
      "  if (error instanceof AppError) {",
      "    return Response.json(",
      "      { error: error.userMessage },",
      "      { status: error.statusCode }",
      "    );",
      "  }",
      "",
      "  // Never expose internal errors",
      "  return Response.json(",
      "    { error: 'An unexpected error occurred' },",
      "    { status: 500 }",
      "  );",
      "}",
      "",
      "${0}"
    ],
    "description": "Error handling that prevents information leakage"
  },
  
  "Secure Crypto Random": {
    "prefix": ["vc-random", "secure-random"],
    "body": [
      "// VibeCheck: Cryptographically secure random values",
      "import { randomBytes, randomUUID } from 'crypto';",
      "",
      "export function generateSecureToken(bytes = 32): string {",
      "  return randomBytes(bytes).toString('hex');",
      "}",
      "",
      "export function generateSecureId(): string {",
      "  return randomUUID();",
      "}",
      "",
      "export function generateOtp(length = 6): string {",
      "  const max = Math.pow(10, length);",
      "  const randomNum = parseInt(randomBytes(4).toString('hex'), 16) % max;",
      "  return randomNum.toString().padStart(length, '0');",
      "}",
      "",
      "${0}"
    ],
    "description": "Generate cryptographically secure random values"
  }
}
